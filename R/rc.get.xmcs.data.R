#' rc.get.xcms.data
#'
#' extractor for xcms objects in preparation for clustering  
#'
#' @param xcmsObj xcmsObject: containing grouped feature data for clustering by ramclustR
#' @param MStag character: character string in 'taglocation' to designate files as either MS / DIA(MSe, idMSMS) e.g. "01.mzML"
#' @param idMSMStag character: character string in 'taglocation' to designate files as either MS / DIA(MSe, idMSMS) e.g. "02.mzML"
#' @param taglocation character: "filepaths" by default, "phenoData[,1]" is another option. referse to xcms slot
#' @param ExpDes either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output
#' @param mzdec integer: number of decimal places used in printing m/z values
#' @details This function creates a ramclustObj which will be used as input for clustering.
#' @return  an empty ramclustR object.  this object is formatted as an hclust object with additional slots for holding feature and compound data. details on these found below. 
#' @return   $frt: feature retention time, in whatever units were fed in (xcms uses seconds, by default)
#' @return   $fmz: feature retention time, reported in number of decimal points selected in ramclustR function
#' @return   $ExpDes: the experimental design object used when running ramclustR.  List of two dataframes. 
#' @return   $MSdata:  the MSdataset provided by either xcms or csv input
#' @return   $MSMSdata: the (optional) MSe/idMSMS dataset provided be either xcms or csv input
#' @return   $xcmsOrd: original xcms order of features, for back-referencing when necessary
#' @msint    $weighted.mean intensity of feature in ms level data
#' @msmsint  $weighted.mean intensity of feature in msms level data
#' 
#' @references Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.
#' @references Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.
#' @concept ramclustR
#' @concept RAMClustR
#' @concept metabolomics
#' @concept mass spectrometry
#' @concept clustering
#' @concept feature
#' @concept MSFinder
#' @concept xcms
#' @author Corey Broeckling
#' @export

rc.get.xcms.data  <- function(xcmsObj=NULL,
                       taglocation="filepaths",
                       MStag=NULL,
                       idMSMStag=NULL, 
                       ExpDes=NULL,
                       mzdec=3
) {
  
  ########
  # If experimental design is NULL: 
  if(is.null(ExpDes)) {
    ExpDes <- defineExperiment(force.skip = TRUE)
    warning('\n', "you failed to define your experimental descriptor using 'defineExperiment()'", '\n',
            "RAMClustR must now guess at what you are trying to do ", '\n',
            "and your exported spectra will be labelled incorrectly")
    if(!is.null(idmsms)) {
      ExpDes[[2]][which(row.names(ExpDes[[2]]) == "MSlevs"),1]<-2
    }
  }
  
  history <- list()
  history$input <- "XCMS output data was used as input to RAMClustR. "
  ## add xcms processing history narrative here
  
  ## check xcms object presence
  if(is.null(xcmsObj)){
    stop('please supply an xcms object as input', '\n')
  }
  
  ## check xcms format
  newXCMS <- FALSE
  if(!is.null(xcmsObj)){
    
    if (!requireNamespace("xcms", quietly = TRUE)) {
      stop("The use of this function requires package 'xcms'. Please ",
           "install with 'Biobase::install(\"xcms\")'")
    }
    
    OK <- FALSE
    
    if(class(xcmsObj)=="xcmsSet") {OK <- TRUE} 
    if(class(xcmsObj) == "XCMSnExp") {
      OK <- TRUE
      newXCMS <- TRUE
    }
    if(!OK) {stop("xcmsObj must reference an object generated by XCMS, of class 'xcmsSet'")}
  }
  
  ## check to see that we can find the MS2 data files
  
  ##  check to see if we have MS2 data, if not, error or switch to ms1
  if(!is.null(idMSMStag)) {
    if(is.null(taglocation)){
      stop("you must specify the the MStag, idMSMStag, and the taglocations")
    }
    if(!any(grepl(taglocation, c("filepaths", "pheno")))) {
      stop("taglocation needs to be one of 'filepaths' or 'pheno'", '\n')
    }
  }
  
  ## get files for MS2 data and total file number
  if(taglocation == 'filepaths') {
    if(!newXCMS) {
      nfiles    <-  length(xcmsObj@filepaths)
      msmsfiles <-  grep(idMSMStag, xcmsObj@filepaths, ignore.case=TRUE)
    }
    if(newXCMS) {
      nfiles    <-length(xcmsObj@processingData@files)
      msmsfiles <-grep(idMSMStag, xcmsObj@processingData@files, ignore.case=TRUE)
    }
  }
  if(taglocation == 'pheno') {
    if(!newXCMS) {
      nfiles    <- length(xcmsObj@phenoData)
      msmsfiles <- grep(idMSMStag, row.names(xcmsObj@phenoData), ignore.case=TRUE)
    }
    if(newXCMS) {
      nfiles    <- length(xcmsObj@phenoData[[1]])
      msmsfiles <- grep(idMSMStag, as.vector(xcmsObj@phenoData[[1]]), ignore.case=TRUE)
    }
  }
  
  if(length(msmsfiles) == 0)  {
    warning('no idMSMS files found - assuming all data is MS1', '\n')
    msfiles <- 1:nfiles
    mslev <- 1
  } else {
    msfiles <- (1:nfiles)[-msmsfiles]
    mslev <- 2
  }
  
  ## check to make sure same number of MS and MSMS files
  if(length(msfiles) != length(msmsfiles)) {
    stop('detected ', length(msfiles), " ms files and ", length(msmsfiles), " msms files - ", '\n', "       number of MSMS files MUST be identical to number of MS files")
  } 
  
  if(!newXCMS) {sampnames<-row.names(xcmsObj@phenoData)}  ## is this right??
  if(newXCMS)  {sampnames <- as.vector(xcmsObj@phenoData[[1]])}
  if(!newXCMS) {data <- t(xcms::groupval(xcmsObj, value="into"))}
  if(newXCMS)  {data <- t(xcms::featureValues(xcmsObj, value = "into"))}
  
  if(length(msfiles) == 0) {stop("no msfiles recognized")}
  
  
  ## create empty hclust object to ultimately hold clustering data
  ramclustObj <- list()
  class(ramclustObj)       <- "hclust"
  ramclustObj$merger       <- vector(length = 0)
  ramclustObj$height       <- vector(length = 0)
  ramclustObj$order        <- vector(length = 0)
  ramclustObj$labels       <- vector(length = 0)
  ramclustObj$method       <- vector(length = 0)
  ramclustObj$call         <- vector(length = 0)
  ramclustObj$dist.method  <- vector(length = 0)
  ramclustObj$ExpDes       <- ExpDes
  
  
  ## process data
  
  # get feature RTs
  if(!newXCMS) {times<-round(xcmsObj@groups[,"rtmed"], digits=3)}
  if(newXCMS) {times<-round(xcmsObj@msFeatureData$featureDefinitions$rtmed, digits = 3)}
  if(any(is.na(times))) {
    do<-which(is.na(times))
    for(x in 1:length(do)) {
      if(!newXCMS) {
        times[do[x]]<-  as.numeric((xcmsObj@groups[do[x],"rtmin"]+ xcmsObj@groups[do[x],"rtmax"])/2)
      }
      if(newXCMS) {
        times[do[x]] <- as.numeric((xcmsObj@msFeatureData$featureDefinitions$rtmin[do[x]] + xcmsObj@msFeatureData$featureDefinitions$rtmax[do[x]])/2)
      }
    }
  }
  
  # get feature MZs
  if(!newXCMS)    {mzs<-round(xcmsObj@groups[,"mzmed"], digits=mzdec)}
  if(newXCMS)     {mzs<-round(xcmsObj@msFeatureData$featureDefinitions$mzmed, digits = mzdec)}
  
  # reorder feature data by RT, record original xcmsOrder
  xcmsOrd <- order(times)
  data<-data[,xcmsOrd]
  mzs<-mzs[xcmsOrd]
  times<-times[xcmsOrd]
  featnames<-paste(mzs, "_", times, sep="")
  dimnames(data)[[2]]<-featnames
  
  ramclustObj$MSdata <- data[msfiles,]
  row.names(ramclustObj$MSdata)<-sampnames
  msint<-rep(0, length(ramclustObj$fmz))
  for(i in 1:ncol(ramclustObj$MSdata)){
    msint[i]<-weighted.mean(ramclustObj$MSdata[,i], ramclustObj$MSdata[,i])
  }
  
  if(mslev == 2) {
    ramclustObj$MSMSdata <- data[msmsfiles,]
    row.names(ramclustObj$MSMSdata)<-sampnames
  }
  
  ramclustObj$frt <- times
  ramclustObj$fmz <- mzs
  ramclustObj$xcmsOrd<-xcmsOrd
  ramclustObj$msint <- msint
  
  if(mslev == 2) {
    msmsint<-rep(0, length(ramclustObj$fmz))
    for(i in 1:ncol(ramclustObj$MSMSdata)){
      msmsint[i]<-weighted.mean(ramclustObj$MSMSdata[,i], ramclustObj$MSMSdata[,i])
    }
    ramclustObj$msmsint <- msmsint
  }

  return(ramclustObj)
}

