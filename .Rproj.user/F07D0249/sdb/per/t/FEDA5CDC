{
    "collab_server" : "",
    "contents" : "#' ramclustR\n#'\n#' Main clustering function for grouping features based on their analytical behavior.  \n#'\n#' @param xcmsObj xcmsObject: containing grouped feature data for clustering by ramclustR\n#' @param ms filepath: optional csv input. Features as columns, rows as samples. Column header mz_rt\n#' @param idmsms filepath: optional idMSMS / MSe csv data.  same dim and names as ms required\n#' @param idMSMStag character: character string in 'taglocation' to designat idMSMS / MSe files e.g. \"02.cdf\"\n#' @param taglocation character: \"filepaths\" by default, \"phenoData[,1]\" is another option. referse to xcms slot\n#' @param featdelim character: how feature mz and rt are delimited in csv import column header e.g. =\"-\"\n#' @param timepos integer: which position in delimited column header represents the retention time (csv only)\n#' @param st numeric: sigma t - time similarity decay value \n#' @param sr numeric: sigma r - correlational similarity decay value\n#' @param maxt numeric: maximum time difference to calculate retention similarity for - all values beyond this are assigned similarity of zero\n#' @param deepSplit logical: controls how agressively the HCA tree is cut - see ?cutreeDynamicTree\n#' @param blocksize integer: number of features (scans?) processed in one block  =1000,\n#' @param mult numeric: internal value, can be used to influence processing speed/ram usage\n#' @param hmax numeric: precut the tree at this height, default 0.3 - see ?cutreeDynamicTree\n#' @param sampNameCol integer: which column from the csv file contains sample names?\n#' @param collapse logical: reduce feature intensities to spectrum intensities?\n#' @param usePheno logical: tranfer phenotype data from XCMS object to SpecAbund dataset?\n#' @param mspout logical: write msp formatted specta to file?\n#' @param ExpDes either an R object created by R ExpDes object: data used for record keeping and labelling msp spectral output\n#' @param normalize character: either \"none\", \"TIC\", or \"quantile\" normalization of feature intensities\n#' @param minModuleSize integer: how many features must be part of a cluster to be returned? default = 2\n#' @param linkage character: heirarchical clustering linkage method - see ?hclust\n#' @param mzdec integer: number of decimal places used in printing m/z values\n#' @param cor.method character: which correlational method used to calculate 'r' - see ?cor\n#'\n#' @details Main clustering function output - see citation for algorithm description of vignette('RAMClustR') for a walk through\n#' @return   featclus: integer vector of cluster membership for each feature\n#' @return   frt: feature retention time, in whatever units were fed in (xcms uses seconds, by default)\n#' @return   fmz: feature retention time, reported in number of decimal points selected in ramclustR function\n#' @return   xcmsOrd: the original XCMS (or csv) feature order for cross referencing, if need be\n#' @return   clrt: cluster retention time\n#' @return   clrtsd: retention time standard deviation of all the features that comprise that cluster\n#' @return   nfeat: number of features in the cluster\n#' @return   nsing: number of 'singletons' - that is the number of features which clustered with no other feature\n#' @return   ExpDes: the experimental design object used when running ramclustR.  List of two dataframes. \n#' @return   cmpd: compound name.  C#### are assigned in order of output by dynamicTreeCut.  Compound with the most features is classified as C0001...\n#' @return   ann: annotation.  By default, annotation names are identical to 'cmpd' names.  This slot is a placeholder for when annotations are provided\n#' @return   MSdata:  the MSdataset provided by either xcms or csv input\n#' @return   MSMSdata: the (optional) MSe/idMSMS dataset provided be either xcms or csv input\n#' @return   SpecAbund: the cluster intensities after collapsing features to clusters\n#' @return   SpecAbundAve: the cluster intensities after averaging all samples with identical sample names\n#' @return   - 'spectra' directory is created in the working directory.  In this directory a .msp is (optionally) created, which contains the spectra for all compounds in the dataset following clustering.  if MSe/idMSMS data are provided, they are listed witht he same compound name as the MS spectrum, with the collision energy provided in the ExpDes object provided to distinguish low from high CE spectra. \n#' @references Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.\n#' @references Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.\n#' @author Corey Broeckling\n#' @export\n\nramclustR<- function(  xcmsObj=NULL,\n                       ms=NULL, \n                       idmsms=NULL,\n                       taglocation=\"filepaths\",\n                       MStag=NULL,\n                       idMSMStag=NULL, \n                       featdelim=\"_\", \n                       mzpos=1, \n                       timepos=2, \n                       st=NULL, \n                       sr=NULL, \n                       maxt=NULL, \n                       deepSplit=FALSE, \n                       blocksize=2000,\n                       mult=5,\n                       hmax=NULL,\n                       sampNameCol=1,\n                       collapse=TRUE,\n                       usePheno=TRUE,\n                       mspout=TRUE, \n                       ExpDes=NULL,\n                       normalize=\"TIC\",\n                       minModuleSize=2,\n                       linkage=\"average\",\n                       mzdec=4,\n                       cor.method=\"pearson\"\n) {\n  \n  ########\n  # load packages\n  require(xcms, quietly=TRUE)\n  require(ff, quietly=TRUE)\n  require(fastcluster, quietly=TRUE)\n  require(dynamicTreeCut, quietly=TRUE)\n  \n  ########\n  # define ms levels, used several tims below\n  mslev <- as.integer(as.numeric(as.character(ExpDes[[2]][nrow(ExpDes[[2]]),1])))\n  \n  \n  ########\n  # do some checks to make sure we have everything we need before proceeding\n  if(is.null(xcmsObj) & is.null(ms))  {\n    stop(\"you must select either \n          1: an MS dataset with features as columns \n             (__)one column may contain sample names, defined by sampNameCol) \n          2: an xcmsObj. If you choose an xcms object, set taglocation: 'filepaths' by default\n            and both MStag and idMSMStag\")}\n  \n  if(!is.null(xcmsObj) & mslev==2 & any(is.null(MStag), is.null(idMSMStag), is.null(taglocation)))\n  {stop(\"you must specify the the MStag, idMSMStag, and the taglocations\")}\n  \n  if( normalize!=\"none\"  & normalize!=\"TIC\" & normalize!=\"quantile\") {\n    stop(\"please selected either 'none', 'TIC', or 'quantile' for the normalize setting\")}\n  \n\n  a<-Sys.time()   \n  \n  ########\n  # set default parameters of not defined in function call\n  \n  if(is.null(hmax)) {hmax<-0.3}\n  \n  \n  ########\n  # if csv input of MS data, do this: \n  if(!is.null(ms)){\n    if(is.null(st)) stop(\"please specify st: \n      a recommended starting point is half the value of \n      your average chromatographic peak width at half max (seconds)\")\n    if(is.null(sr)) sr<-0.5\n    if(is.null(maxt)) maxt<-60\n    MSdata<-read.csv(file = ms, header=TRUE, check.names=FALSE)\n    if(!is.null(idmsms)){\n      MSMSdata<-read.csv(file = idmsms, header=TRUE, check.names=FALSE)}\n    if(is.null(idmsms)) { MSMSdata<-MSdata}\n    if(is.null(sampNameCol)) {featcol<-1:ncol(MSdata)} else {\n      featcol<-setdiff(1:(ncol(MSdata)), sampNameCol)}\n    if(is.null(sampNameCol)) {featcol<-1:ncol(MSdata)} else {\n      featcol<-setdiff(1:(ncol(MSdata)), sampNameCol)}\n    sampnames<-MSdata[,sampNameCol]\n    data1<-as.matrix(MSdata[,featcol])\n    dimnames(data1)[[1]]<-MSdata[,sampNameCol]\n    dimnames(data1)[[2]]<-names(MSdata[,featcol])\n    data2<-as.matrix(MSMSdata[,featcol])\n    dimnames(data2)[[1]]<-MSMSdata[,sampNameCol]\n    dimnames(data2)[[2]]<-names(MSMSdata[,featcol])\n    if(!all(dimnames(data1)[[2]]==dimnames(data2)[[2]])) \n    {stop(\"the feature names of your MS and idMSMS data are not identical\")}\n    \n    if(!all(dimnames(data1)[[1]]==dimnames(data2)[[1]])) \n    {stop(\"the order and names of your MS and idMSMS data sample names are not identical\")}\n    \n    rtmz<-matrix(\n      unlist(\n        strsplit(dimnames(data1)[[2]], featdelim)\n      ), \n      byrow=TRUE, ncol=2)\n    times<-as.numeric(rtmz[,timepos])\n    mzs<-as.numeric(rtmz[,which(c(1:2)!=timepos)])\n    rm(rtmz)\n  }\n  \n  ########\n  # if xcms object as input, do this:\n  if(!is.null(xcmsObj)){\n    if(!class(xcmsObj)==\"xcmsSet\")\n    {stop(\"xcmsObj must reference an object generated by XCMS, of class 'xcmsSet'\")}\n    \n    if(is.null(st)) st<-round(median(xcmsObj@peaks[,\"rtmax\"]-xcmsObj@peaks[,\"rtmin\"])/2, digits=2)\n    if(is.null(sr)) sr<-0.5\n    if(is.null(maxt)) maxt<-st*20\n    \n    sampnames<-row.names(xcmsObj@phenoData)\n    data12<-groupval(xcmsObj, value=\"into\")\n    \n    if(taglocation==\"filepaths\" & !is.null(MStag)) \n    { msfiles<-grep(MStag, xcmsObj@filepaths, ignore.case=TRUE)\n    msmsfiles<-grep(idMSMStag, xcmsObj@filepaths, ignore.case=TRUE)\n    if(length(intersect(msfiles, msmsfiles)>0)) \n    {stop(\"your MS and idMSMStag values do not generate unique file lists\")}\n    if(length(msfiles)!=length(msmsfiles)) \n    {stop(\"the number of MS files must equal the number of MSMS files\")}\n    data1<-t(data12[,msfiles])\n    row.names(data1)<-sampnames[msfiles]\n    data2<-t(data12[,msmsfiles])\n    row.names(data2)<-sampnames[msmsfiles]  ##this may need to be changed to dimnames..\n    times<-round(xcmsObj@groups[,\"rtmed\"], digits=3)\n    if(any(is.na(times))) {\n      do<-which(is.na(times))\n      for(x in 1:length(do)) {\n        times[do[x]]<-  as.numeric((xcmsObj@groups[do[x],\"rtmin\"]+ xcmsObj@groups[do[x],\"rtmax\"])/2)\n      }\n    }\n    # if(any(is.na(times))) {stop(\"na values still present\")} else {print(\"NAs removed\")}\n    mzs<-round(xcmsObj@groups[,\"mzmed\"], digits=4)\n    } else {\n      data1<-t(data12)\n      msfiles<-1:nrow(data1)\n      data2<-t(data12)\n      times<-round(xcmsObj@groups[,\"rtmed\"], digits=3)\n      mzs<-round(xcmsObj@groups[,\"mzmed\"], digits=4) \n      if(any(is.na(times))) {\n        do<-which(is.na(times))\n        for(x in 1:length(do)) {\n          times[do[x]]<-  as.numeric((xcmsObj@groups[do[x],\"rtmin\"]+ xcmsObj@groups[do[x],\"rtmax\"])/2)\n        }\n      }\n      #if(any(is.na(times))) {stop(\"na values still present\")} else {print(\"NAs removed\")}\n    }\n  }\n  \n  \n  ########\n  # ensure that we have all numeric values in the dataset. \n  # uses a noise addition 'jitter' around minimum values with missing data points.\n  # this is mostly necessary for csv input, where other programs may not have used a 'fillPeaks' like step\n  rpl1<-unique(c(which(is.na(data1)), which(is.nan(data1)), which(is.infinite(data1)), which(data1==0)))\n  rpl2<-unique(c(which(is.na(data2)), which(is.nan(data2)), which(is.infinite(data2)), which(data2==0)))\n  if(length(rpl1)>0) {data1[rpl1]<-abs(jitter(rep(min(data1, na.rm=TRUE), length(rpl1) ), amount=min(data1/100, na.rm=TRUE)))}\n  if(length(rpl2)>0) {data2[rpl2]<-abs(jitter(rep(min(data2, na.rm=TRUE), length(rpl2) ), amount=min(data2/100, na.rm=TRUE)))}\n  #if(length(rpl1)>0) {data1[rpl1]<-abs(jitter(rep(min(data1, na.rm=TRUE), length(rpl1) ), amount=min(data1/100, na.rm=TRUE)))}\n  #if(length(rpl2)>0) {data2[rpl2]<-abs(jitter(rep(min(data2, na.rm=TRUE), length(rpl2) ), amount=min(data2/100, na.rm=TRUE)))}\n  data1[which(data1<0)]<-abs(data1[which(data1<0)])\n  data2[which(data2<0)]<-abs(data2[which(data2<0)])\n  \n  ########\n  # Optional normalization of data, either Total ion signal or quantile\n  \n  if(normalize==\"TIC\") {\n    data1<-(data1/rowSums(data1))*mean(rowSums(data1), na.rm=TRUE)\n    data2<-(data2/rowSums(data2))*mean(rowSums(data2), na.rm=TRUE)\n  }\n  if(normalize==\"quantile\") {\n    data1<-t(preprocessCore::normalize.quantiles(t(data1)))\n    data2<-t(preprocessCore::normalize.quantiles(t(data2)))\t\n  }\n  \n  ########\n  # data organization and parsing \n  # sort rt vector and data by retention time\n  xcmsOrd<-order(times)\n  data1<-data1[,order(times)]\n  data2<-data2[,order(times)]\n  mzs<-mzs[order(times)]\n  times<-times[order(times)]\n  featnames<-paste(mzs, \"_\", times, sep=\"\")\n  dimnames(data1)[[2]]<-featnames\n  dimnames(data2)[[2]]<-featnames\n  \n  ########\n  # establish some constants for downstream processing\n  n<-ncol(data1)\n  vlength<-(n*(n-1))/2\n  nblocks<-floor(n/blocksize)\n  \n  ########\n  # set off ff matrix system for holding data. \n  # manages RAM demands a bit.  \n  ffmat<-ff(vmode=\"double\", dim=c(n, n), initdata = 0) ##reset to 1 if necessary\n  gc()\n  #Sys.sleep((n^2)/10000000)\n  #gc()\n  \n  ########\n  # make list of all row and column blocks to evaluate\n  eval1<-expand.grid(0:nblocks, 0:nblocks)\n  names(eval1)<-c(\"j\", \"k\") #j for cols, k for rows\n  eval1<-eval1[which(eval1[,\"j\"]<=eval1[,\"k\"]),] #upper triangle only\n  bl<-nrow(eval1)\n  cat('\\n', paste(\"calculating ramclustR similarity: nblocks = \", bl))\n  cat('\\n', \"finished:\")\n  \n  \n  ########\n  # Define the RCsim function used to calculate feature similarities on selected blocks of data\n  RCsim<-function(bl)  {\n    cat(bl,' ')\n    j<-eval1[bl,\"j\"]  #columns\n    k<-eval1[bl,\"k\"]  #rows\n    startc<-min((1+(j*blocksize)), n)\n    if ((j+1)*blocksize > n) {\n      stopc<-n} else {\n        stopc<-(j+1)*blocksize}\n    startr<-min((1+(k*blocksize)), n)\n    if ((k+1)*blocksize > n) {\n      stopr<-n} else {\n        stopr<-(k+1)*blocksize}\n    if(startc<=startr) { \n      mint<-min(abs(outer(range(times[startr:stopr]), range(times[startc:stopc]), FUN=\"-\")))\n      if(mint<=maxt) {\n        temp1<-round(exp(-(( (abs(outer(times[startr:stopr], times[startc:stopc], FUN=\"-\"))))^2)/(2*(st^2))), \n                     \n                     digits=20 )\n\n        temp2<-round (exp(-((1-(pmax(  cor(data1[,startr:stopr], data1[,startc:stopc], method=cor.method),\n                                       cor(data1[,startr:stopr], data2[,startc:stopc], method=cor.method),\n                                       cor(data2[,startr:stopr], data2[,startc:stopc], method=cor.method)  )))^2)/(2*(sr^2))), \n                      \n                      digits=20 )\t\t\n        #ffcor[startr:stopr, startc:stopc]<-temp\n        temp<- 1-(temp1*temp2)\n        temp[which(is.nan(temp))]<-1\n        temp[which(is.na(temp))]<-1\n        temp[which(is.infinite(temp))]<-1\n        ffmat[startr:stopr, startc:stopc]<-temp\n        rm(temp1); rm(temp2); rm(temp)\n        gc()} \n      if(mint>maxt) {ffmat[startr:stopr, startc:stopc]<- 1}\n    }\n    gc()}\n  \n  ########\n  # Call the similarity scoring function\n  system.time(sapply(1:bl, RCsim))\n  \n  b<-Sys.time()\n  \n  ########\n  # Report progress and timing\n  cat('\\n','\\n' )\n  cat(paste(\"RAMClust feature similarity matrix calculated and stored:\", \n            round(difftime(b, a, units=\"mins\"), digits=1), \"minutes\"))\n  gc() \n  \n  \n  ########\n  # extract lower diagonal of ffmat as vector\n  blocksize<-mult*round(blocksize^2/n)\n  nblocks<-floor(n/blocksize)\n  remaind<-n-(nblocks*blocksize)\n  \n  ########\n  # create vector for storing dissimilarities\n  ramclustObj<-vector(mode=\"integer\", length=vlength)\n  \n  ########\n  # fill vector with dissimilarities\n  for(k in 0:(nblocks)){\n    startc<-1+(k*blocksize)\n    if ((k+1)*blocksize > n) {\n      stopc<-n} else {\n        stopc<-(k+1)*blocksize}\n    temp<-ffmat[startc:nrow(ffmat),startc:stopc]\n    temp<-temp[which(row(temp)-col(temp)>0)]\n    if(exists(\"startv\")==FALSE) startv<-1\n    stopv<-startv+length(temp)-1\n    ramclustObj[startv:stopv]<-temp\n    gc()\n    startv<-stopv+1\n    rm(temp)\n    gc()\n  }    \n  rm(startv)\n  gc()\n  \n  ########\n  # convert vector to distance formatted object\n  ramclustObj<-structure(ramclustObj, Size=(n), Diag=FALSE, Upper=FALSE, method=\"RAMClustR\", Labels=featnames, class=\"dist\")\n  gc()\n  \n  c<-Sys.time()    \n  cat('\\n', '\\n')\n  cat(paste(\"RAMClust distances converted to distance object:\", \n            round(difftime(c, b, units=\"mins\"), digits=1), \"minutes\"))\n  \n  ########\n  # cleanup\n  delete.ff(ffmat)\n  rm(ffmat)\n  gc()\n  \n  \n  ########\n  # cluster using fastcluster package,\n  system.time(ramclustObj<-hclust(ramclustObj, method=linkage))\n  gc()\n  d<-Sys.time()    \n  cat('\\n', '\\n')    \n  cat(paste(\"fastcluster based clustering complete:\", \n            round(difftime(d, c, units=\"mins\"), digits=1), \"minutes\"))\n  if(minModuleSize==1) {\n    clus<-cutreeDynamicTree(ramclustObj, maxTreeHeight=hmax, deepSplit=deepSplit, minModuleSize=2)\n    sing<-which(clus==0)\n    clus[sing]<-max(clus)+1:length(sing)\n  }\n  if(minModuleSize>1) {\n    clus<-cutreeDynamicTree(ramclustObj, maxTreeHeight=hmax, deepSplit=deepSplit, minModuleSize=minModuleSize)\n  }\n  gc()\n  \n  ########\n  # build results into ramclustObj\n  ramclustObj$featclus<-clus\n  ramclustObj$frt<-times\n  ramclustObj$fmz<-mzs\n  ramclustObj$xcmsOrd<-xcmsOrd\n  msint<-rep(0, length(ramclustObj$fmz))\n  for(i in 1:ncol(data1)){\n    msint[i]<-weighted.mean(data1[,i], data1[,i])\n  }\n  ramclustObj$msint<-msint\n  \n  if(mslev==2) {\n    msmsint<-rep(0, length(ramclustObj$fmz))\t\n    for(i in 1:ncol(data1)){\t\n      msmsint[i]<-weighted.mean(data2[,i], data2[,i])\n    }\n    ramclustObj$msmsint<-msmsint\n  }\n  \n  clrt<-aggregate(ramclustObj$frt, by=list(ramclustObj$featclus), FUN=\"mean\")\n  ramclustObj$clrt<-clrt[which(clrt[,1]!=0),2]\n  clrtsd<-aggregate(ramclustObj$frt, by=list(ramclustObj$featclus), FUN=\"sd\")\n  ramclustObj$clrtsd<-clrtsd[which(clrtsd[,1]!=0),2]\n  \n  ramclustObj$nfeat<-as.vector(table(ramclustObj$featclus)[2:max(ramclustObj$featclus)])\n  ramclustObj$nsing<-length(which(ramclustObj$featclus==0))\n  \n  e<-Sys.time() \n  cat('\\n', '\\n')\n  cat(paste(\"dynamicTreeCut based pruning complete:\", \n            round(difftime(e, d, units=\"mins\"), digits=1), \"minutes\"))\n  \n  f<-Sys.time()\n  cat('\\n', '\\n')\n  cat(paste(\"RAMClust has condensed\", n, \"features into\",  max(clus), \"spectra in\", round(difftime(f, a, \n                                                                                                   \n                                                                                                   units=\"mins\"), digits=1), \"minutes\", '\\n'))\n  \n  ramclustObj$ExpDes<-ExpDes\n  strl<-nchar(max(ramclustObj$featclus)) - 1\n  ramclustObj$cmpd<-paste(\"C\", formatC(1:length(ramclustObj$clrt), digits = strl, flag = 0 ) , sep=\"\")\n  # cat(ramclustObj$cmpd[1:10], '\\n')\n  ramclustObj$ann<-ramclustObj$cmpd\n  ramclustObj$annconf<-rep(\"\", length(ramclustObj$clrt))\n  ramclustObj$annnotes<-rep(\"\", length(ramclustObj$clrt))\n  ramclustObj$MSdata<-data1\n  if(mslev==2) ramclustObj$MSMSdata<-data2  \n  \n  ########\n  # collapse feature dataset into spectrum dataset\n  if(collapse==\"TRUE\") {\n    cat('\\n', '\\n', \"... collapsing features into spectra\")\n    wts<-colSums(data1[])\n    ramclustObj$SpecAbund<-matrix(nrow=nrow(data1), ncol=max(clus))\n    for (ro in 1:nrow(ramclustObj$SpecAbund)) { \n      for (co in 1:ncol(ramclustObj$SpecAbund)) {\n        ramclustObj$SpecAbund[ro,co]<- weighted.mean(data1[ro,which(ramclustObj$featclus==co)], wts[which(ramclustObj$featclus==co)])\n      }\n    }\n    dimnames(ramclustObj$SpecAbund)[[2]]<-ramclustObj$cmpd\n    if(!usePheno | is.null(xcmsObj)) {dimnames(ramclustObj$SpecAbund)[[1]]<-dimnames(ramclustObj$MSdata)[[1]]} \n    if(usePheno & !is.null(xcmsObj)) {dimnames(ramclustObj$SpecAbund)[[1]]<-as.vector(xcmsObj@phenoData[,1])[msfiles]}\n    g<-Sys.time()\n    cat('\\n', '\\n')\n    cat(paste(\"RAMClustR has collapsed feature quantities\n             into spectral quantities:\", round(difftime(g, f, units=\"mins\"), digits=1), \"minutes\", '\\n'))\n  }\n  \n  ########\n  # further aggregate by sample names for 'SpecAbundAve' dataset\n  \n  rm(data1)\n  rm(data2)\n  if(!is.null(ramclustObj$SpecAbund)) {\n    if(length(dimnames(ramclustObj$SpecAbund)[[1]])> length(unique(dimnames(ramclustObj$SpecAbund)[[1]]))) {\n      ramclustObj$SpecAbundAve<-aggregate(ramclustObj$SpecAbund[,1:ncol(ramclustObj$SpecAbund)], \n                                 by=list(dimnames(ramclustObj$SpecAbund)[[1]]), \n                                 FUN=\"mean\", simplify=TRUE)\n      dimnames(ramclustObj$SpecAbundAve)[[1]]<-ramclustObj$SpecAbundAve[,1]\n      ramclustObj$SpecAbundAve<-as.matrix(ramclustObj$SpecAbundAve[,2:ncol(ramclustObj$SpecAbundAve)])\n      dimnames(ramclustObj$SpecAbundAve)[[2]]<-dimnames(ramclustObj$SpecAbund)[[2]]\n      gc()\n    }\n  }\n  gc()\n  \n  ########\n  # write msp formatted spectra\n  if(mspout==TRUE){ \n    cat(paste(\"writing msp formatted spectra...\", '\\n'))\n    dir.create(\"spectra\")\n    libName<-paste(\"spectra/\", ExpDes[[1]][\"Experiment\", 1], \".mspLib\", sep=\"\")\n    file.create(file=libName)\n    for (m in 1:as.numeric(mslev)){\n      for (j in 1:max(ramclustObj$featclus)) {\n        #print(paste(j,\"_\", sep=\"\"))\n        sl<-which(ramclustObj$featclus==j)\n        wm<-vector(length=length(sl))\n        if(m==1) {wts<-rowSums(ramclustObj$MSdata[,sl, drop=FALSE])\n        for (k in 1:length(sl)) {     \n          wm[k]<-weighted.mean(ramclustObj$MSdata[,sl[k]], wts)\n        }}\n        if(m==2) {wts<-rowSums(ramclustObj$MSMSdata[,sl, drop=FALSE])\n        for (k in 1:length(sl)) {    \n          wm[k]<-weighted.mean(ramclustObj$MSMSdata[,sl[k]], wts)\n        }}\n        mz<-round(ramclustObj$fmz[sl][order(wm, decreasing=TRUE)], digits=mzdec)\n        rt<-ramclustObj$frt[sl][order(wm, decreasing=TRUE)]\n        wm<-round(wm[order(wm, decreasing=TRUE)])\n        mrt<-mean(rt)\n        npeaks<-length(mz)\n        specdat<-\"\"\n        for (l in 1:length(mz)) {\n          specdat<-paste(specdat, mz[l], \" \", wm[l], '\\n', sep=\"\")\n        }\n        cat(\n          paste(\"Name: \", ramclustObj$cmpd[j], sep=\"\"), '\\n',\n          paste(\"SYNON: $:00in-source\", sep=\"\"), '\\n',\n          paste(\"SYNON: $:04\", sep=\"\"), '\\n', \n          paste(\"SYNON: $:05\", if(m==1) {ExpDes[[2]][\"CE1\", 1]} else {ExpDes$instrument[\"CE2\", \"InstVals\"]}, sep=\"\"), '\\n',\n          paste(\"SYNON: $:06\", ExpDes[[2]][\"mstype\", 1], sep=\"\"), '\\n',           #mstype\n          paste(\"SYNON: $:07\", ExpDes[[2]][\"msinst\", 1], sep=\"\"), '\\n',           #msinst\n          paste(\"SYNON: $:09\", ExpDes[[2]][\"chrominst\", 1], sep=\"\"), '\\n',        #chrominst\n          paste(\"SYNON: $:10\", ExpDes[[2]][\"ionization\", 1], sep=\"\"),  '\\n',      #ionization method\n          paste(\"SYNON: $:11\", ExpDes[[2]][\"msmode\", 1], sep=\"\"), '\\n',           #msmode\n          if(any(row.names(ExpDes[[2]])==\"colgas\")) {\n            paste(\"SYNON: $:12\", ExpDes[[2]][\"colgas\", 1], '\\n', sep=\"\") \n            },          #collision gas\n          paste(\"SYNON: $:14\", ExpDes[[2]][\"msscanrange\", 1], sep=\"\"), '\\n',      #ms scanrange\n          if(any(row.names(ExpDes[[2]])==\"conevolt\")) {\n            paste(\"SYNON: $:16\", ExpDes[[2]][\"conevolt\", 1], '\\n', sep=\"\")\n            },         #conevoltage\n          paste(\"Comment: Rt=\", round(mrt, digits=2), \n                \"  Contributor=\", ExpDes[[1]][\"Contributor\", 1], \n                \"  Study=\", ExpDes[[1]][\"Experiment\", 1], \n                sep=\"\"), '\\n',\n          paste(\"Num Peaks:\", npeaks), '\\n',\n          paste(specdat), '\\n', sep=\"\", file=libName, append= TRUE)\n      }\n    }\n    cat(paste('\\n', \"msp file complete\", '\\n')) \n  }  \n  return(ramclustObj)\n}\n",
    "created" : 1506350281634.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2108119329",
    "id" : "FEDA5CDC",
    "lastKnownWriteTime" : 1506536720,
    "last_content_update" : 1506536720295,
    "path" : "~/GitHub/RAMClustR/R/ramclustR.R",
    "project_path" : "R/ramclustR.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}