{
    "collab_server" : "",
    "contents" : "#' do.findmain\n#'\n#' cluster annotation function \n#'\n#' This is the Details section\n#'\n#' @param ramclustObj ramclustR object to annotate. \n#' @param cmpd integer: vector defining compound numbers to annotated.  if NULL (default), all compounds\n#' @param mode character: \"positive\" or \"negative\"\n#' @param mzabs.error numeric: absolute mass deviation allowd\n#' @param ppm.error numeric: ppm mass error added to mzabs.error\n#' @param ads character: vector of allowed adducts, i.e. c(\"[M+H]+\"). if NULL, default values of H+, Na+, K+, and NH4+, as monomer, dimer, and trimer, are assigned.\n#' @param nls  character: vector of allowed neutral losses, i.e. c(\"[M+H-H2O]+\").  if NULL, an extensive list derived from CAMERA's will be used. \n#' @param adwts numeric: vector of weights for adducts. length should match that of 'ads', else first value will be repeated.  if NULL (default), value of 1 is assigned to all. Only used for ramclustR scoring of M.\n#' @param nlwts numeric: vector of weights for neutral losses. length should match that of 'nls', else first value will be repeated.  if NULL (default), value of 0.1 is assigned to all.  Only used for ramclustR scoring of M.\n#' @param plot.findmain logical: should pdf polts be generated for evaluation?\n#' @param writeMat logical: should indidual .mat files (for MSFinder) be generated in a 'mat' subdirectory in the 'spectra' folder?\n\n#' @return a partially annotated ramclustR object.  base structure is that of a standard R heirarchical clustering output, with additional slots described in ramclustR documentation (?ramclustR).  New slots added after using the interpretMSSpectrum functionality include:\n#' @return more slots to describe. \n#' @return M The inferred molecular weight of the compound giving rise to the each spectrum\n#' @return M.ppm The ppm error of all the MS signals annotated, high error values should be considered 'red flags'\n#' @return M.ann The annotated spectrum supporting the intepretation of M\n#' @return use.findmain  Logical vector indicating whether findmain scoring (TRUE) or ramclustR scoring (FALSE) was used to support inference of M.  By default, findmain scoring is used.  When ramclustR scoring differs from findmain scoring, the scoring metric which predicts higher M is selected. \n#' @return M.ramclustr  M selected using ramclustR scoring\n#' @return M.ppm.ramclustr ppm error of M selected using ramclustR scoring\n#' @return M.ann.ramclustr annotated spectrum supporing M using ramclustR scoring\n#' @return M.findmain M selected using findmain scoring\n#' @return M.ppm.findmain ppm error of M selected using findmain scoring\n#' @return M.ann.findmain annotated spectrum supporing M using findmain scoring\n#' \n#' @references Jaeger C, MÃ©ret M, Schmitt CA, Lisec J. Compound annotation in liquid chromatography/high-resolution mass spectrometry based metabolomics: robust adduct ion determination as a prerequisite to structure prediction in electrospray ionization mass spectra. Rapid Commun Mass Spectrom. 2017 Aug 15;31(15):1261-1266. doi: 10.1002/rcm.7905. PubMed PMID: 28499062.\n#' @references Broeckling CD, Afsar FA, Neumann S, Ben-Hur A, Prenni JE. RAMClust: a novel feature clustering method enables spectral-matching-based annotation for metabolomics data. Anal Chem. 2014 Jul 15;86(14):6812-7. doi: 10.1021/ac501530d.  Epub 2014 Jun 26. PubMed PMID: 24927477.\n#' @references Broeckling CD, Ganna A, Layer M, Brown K, Sutton B, Ingelsson E, Peers G, Prenni JE. Enabling Efficient and Confident Annotation of LC-MS Metabolomics Data through MS1 Spectrum and Time Prediction. Anal Chem. 2016 Sep 20;88(18):9226-34. doi: 10.1021/acs.analchem.6b02479. Epub 2016 Sep 8. PubMed PMID: 7560453.\n#' \n#' @author Corey Broeckling\n#' @export \n\n\ndo.findmain<-function(ramclustObj = RC, \n                      cmpd = NULL,\n                      mode = \"positive\", \n                      mzabs.error = 0.01, \n                      ppm.error = 10, \n                      ads = NULL, \n                      nls = NULL, \n                      adwts = NULL, \n                      nlwts=NULL, \n                      plot.findmain=TRUE, \n                      writeMat=TRUE) {\n  require(InterpretMSSpectrum)\n  \n  #############\n  ## if adducts and neutral losses and weights are undefined, set to defaults\n  \n  if(is.null(ads)) {\n    ads<-c(\"[M+H]+\", \"[M+Na]+\", \"[M+K]+\", \"[M+NH4]+\", \"[2M+H]+\", \"[2M+Na]+\", \n           \"[2M+K]+\", \"[2M+NH4]+\", \"[3M+H]+\", \"[3M+Na]+\", \"[3M+K]+\", \"[3M+NH4]+\")\n  }\n  \n  if(is.null(nls)) {\n    nls<-c(\"[M+H-NH3]+\", \"[M+H-H2O]+\", \"[M+H-COCH2]+\", \"[M+H-CO2]+\", \"[M+H-NH3-CO2]+\", \n           \"[M+H-NH3-HCOOH]+\", \"[M+H-NH3-H2O]+\", \"[M+H-NH3-COCH2]+\", \"[M+H-S]+\", \n           \"[M+H-S-NH3-HCOOH]+\", \"[M+H-H4O2]+\", \"[M+H-CH2]+\", \"[M+H-O]+\", \n           \"[M+H-C2H2]+\", \"[M+H-C2H4]+\", \"[M+H-CO]+\", \"[M+H-C3H6]+\", \"[M+H-C2H4O]+\", \n           \"[M+H-C4H6]+\", \"[M+H-C3H4O]+\", \"[M+H-C4H8]+\", \"[M+H-C5H8]+\", \n           \"[M+H-C4H6O]+\", \"[M+H-C5H10]+\", \"[M+H-C6H12]+\", \"[M+H-C4H8O2]+\", \n           \"[M+H-H2O-HCOOH]+\", \"[M+H-CH4]+\", \"[M+H-CH2O]+\", \"[M+H-C2H6]+\", \n           \"[M+H-CH3OH]+\", \"[M+H-C3H4]+\", \"[M+H-C3H6O]+\", \"[M+H-CO2-C3H6]+\", \n           \"[M+H-SO3]+\", \"[M+H-SO3-H2O]+\", \"[M+H-SO3-H2O-NH3]+\", \"[M+H-NH3-C3H4]+\", \n           \"[M+H-H2O-CO2]+\", \"[M+H-H2O-H2O-C2H4O]+\", \"[M+H-NH3-CO-CO]+\", \n           \"[M+H-NH3-CO-COCH2]+\", \"[M+H-C8H6O]+\", \"[M+H-C8H6O-NH3]+\", \"[M+H-C8H6O-H2O]+\", \n           \"[M+H-C2H2O2]+\", \"[M+H-C2H4O2]+\", \"[M+H-C5H8O]+\", \"[M+H-NH3-CO2-CH2O]+\", \n           \"[M+H-NH3-CO2-NH3-H2O]+\", \"[M+H-NH3-CO2-C3H4O]+\", \"[M+H-NH3-CO2-C5H8]+\", \n           \"[M+H-HCOOH-HCOOH]+\", \"[M+H-C2H4-CO2]+\", \"[M+H-C2H4-HCOOH]+\", \n           \"[M+H-NH3-H2O-H2O]+\", \"[M+H-H2O-C2H2O2]+\", \"[M+H-COCH2-C4H8]+\", \n           \"[M+H-NH3-NH3-C3H4]+\", \"[M+H-C2H4O2-CH3OH]+\", \"[M+H-C3H6O-CH3OH]+\", \n           \"[M+H-NH3-CO-COCH2-C4H6O]+\", \"[M+H-C4H6-H2O]+\", \"[M+H-C4H6-C2H4]+\", \n           \"[M+H-C4H6-NH3-H2O]+\", \"[M+H-C4H6-COCH2]+\", \"[M+H-C4H6-C4H6O]+\", \n           \"[M+H-C3H4O-C4H6]+\", \"[M+H-C3H4O-C4H8O2]+\", \"[M+H-C4H8-C4H6]+\", \n           \"[M+H-NH3-HCOOH-CH3OH]+\", \"[M+H-NH3-C2H6]+\", \"[M+H-NH3-C8H6O-CH2]+\", \n           \"[M+H-NH3-C3H4-COCH2]+\", \"[M+H-C3H9N]+\", \"[M+H-C3H9N-C2H4O2]+\", \n           \"[M+H-C6H10O7]+\", \"[M+H-C6H10O7+H2O]+\", \"[M+H-C6H10O7-(H2O)2]+\", \n           \"[M+H-C6H12O6]+\", \"[M+H-C6H12O6+H2O]+\", \"[M+H-C6H12O6-H2O]+\", \n           \"[M+H-C5H10O5]+\", \"[M+H- C5H10O5+H2O]+\", \"[M+H- C5H10O5-H2O]+\", \n           \"[M+H-C2H8NO4P]+\", \"[M+H-(H2O)3-CO]+\", \"[M+H-C6H13NO2]+\", \"[M+H-C5H11NO2]+\", \n           \"[M+H-CH3S]+\", \"[M+H-C8H8O2]+\", \"[M+H-C12H22O11]+\", \"[M+H-C12H24O12]+\", \n           \"[M+H-C12H20O10]+\")\n  }\n  \n  if(length(adwts)>0) {\n    if(length(adwts) != length(ads)) {\n      if(length(adwts) > 1) {\n        warning(\"adduct weight length not equal to adduct length: assigning weight \", adwts[1], \" to all adduct weights\")\n      }\n      adwts<-rep(adwts[1], length(ads)) \n    } \n  } else  {\n    adwts = rep(1, length(ads))\n  }\n  \n  \n  if(length(nlwts)>0) {\n    if(length(nlwts) != length(nls)) {\n      if(length(nlwts) > 1) {\n        warning(\"adduct weight length not equal to adduct length: assigning weight \", nlwts[1], \" to all adduct weights\")\n      }\n      nlwts<-rep(nlwts[1], length(nls)) \n    } \n  } else  {\n    nlwts = rep(0.1, length(nls))\n  }\n  \n  adnlwts<-c(adwts, nlwts); names(adnlwts)<-c(ads, nls)\n  \n  #############\n  ##  create structure in ramclustObj for holding results\n  \n  M.findmain <- rep(NA, max(ramclustObj$featclus))\n  M.ppm.findmain <- rep(NA, max(ramclustObj$featclus))\n  M.ann.findmain <- as.list(rep(NA, max(ramclustObj$featclus)))\n  M.ramclustr <- rep(NA, max(ramclustObj$featclus))\n  M.ppm.ramclustr <- rep(NA, max(ramclustObj$featclus))\n  M.rank.ramclustr <- rep(NA, max(ramclustObj$featclus))\n  M.ann.ramclustr <- as.list(rep(NA, max(ramclustObj$featclus)))\n  \n  #############\n  ## define (if null) full compound range for analysis\n  \n  if(is.null(cmpd)) {cmpd <- (1:max(ramclustObj$featclus)) }\n  \n  #############\n  ## do findMain for all compounds in 'cmpd', append results to ramclustObj\n  \n  for(cl in cmpd){\n    s<-data.frame(\"mz\"=ramclustObj$fmz[which(ramclustObj$featclus==cl)], \"int\"=ramclustObj$msint[which(ramclustObj$featclus==cl)])\n    \n    out<-findMAIN(\n      s, \n      adductmz = NULL, \n      ionmode = mode,\n      adducthyp = ads, \n      ms2spec = NULL, \n      rules = c(ads, nls),\n      mzabs = mzabs.error,\n      ppm = ppm.error, \n      mainpkthr = 0.1, \n      collapseResults = FALSE)\n    \n    summarytable<-summary(out)\n    \n    M.findmain[cl]<-summarytable[1, \"neutral_mass\"]\n    M.ppm.findmain[cl]<-summarytable[1, \"medppm\"]\n    M.ann.findmain[[cl]]<-out[[1]]\n    \n    \n    #############\n    ## calculate ramclustR scoring\n    \n    ## set all major adduct ppm errors to half ppm.error, or 5\n    for(y in 1:length(out)) {\n      keep<-which(!is.na(out[[y]][,\"adduct\"]))  ## which are annotated peaks\n      out[[y]][keep[which(is.na(out[[y]][keep,\"ppm\"]))],\"ppm\"] <- ppm.error/2\n    }\n    \n    summaryscores<-sapply(\n      1:length(out), \n      FUN=function(x) \n      {\n        keep<-which(!is.na(out[[x]][,\"adduct\"]))  ## which are annotated peaks\n        wt<- adnlwts[out[[x]][keep,\"adduct\"]]\n        int<-(out[[x]][keep, \"int\"])^0.1   ## use square root of intensity to prevent bias toward base peak\n        mzerr<-out[[x]][keep, \"ppm\"] \n        # mzerr[is.na(mzerr)]<-0\n        mzerr<-round(exp(-mzerr^2/(2*(ppm.error^2)) ), digits = 4)  ## this is a sigmoid function to weight high ppm error peaks lower\n        #massorder<-order(out[[x]][keep, \"mz\"])\n        massorder<-sqrt(order(out[[x]][keep, \"mz\"]))\n        massorder<-(massorder)/max((massorder))\n        return(sum((massorder *int * mzerr * wt), na.rm=TRUE) + (0.1*length(keep)))  ## product of the intensity and the scaled mzerror\n        # data.frame(keep, wt, int, mzerr, 'ppm'=out[[x]][keep, \"ppm\"], massorder, 'score'=(massorder *int * mzerr * wt))\n      }\n    )\n\n    best<-which.max(summaryscores)\n    \n    M.ramclustr[cl]<-summarytable[best, \"neutral_mass\"]\n    M.ppm.ramclustr[cl]<-summarytable[best, \"medppm\"]\n    M.rank.ramclustr[cl]<-best\n    M.ann.ramclustr[[cl]]<-out[[best]]\n    \n    #############\n    ## progress reporting\n    if(10*round(cl/10, digits=0) == cl) {\n      cat(cl, \"of\", max(ramclustObj$featclus), '\\n')\n    }\n  } \n  \n  #############\n  ## append all results to ramclustObj\n  ramclustObj$M.ramclustr <- M.ramclustr\n  ramclustObj$M.ppm.ramclustr <- M.ppm.ramclustr\n  ramclustObj$M.rank.ramclustr <- M.rank.ramclustr\n  ramclustObj$M.ann.ramclustr <- M.ann.ramclustr\n  ramclustObj$M.findmain <- M.findmain\n  ramclustObj$M.ppm.findmain <- M.ppm.findmain\n  ramclustObj$M.ann.findmain <- M.ann.findmain\n  ramclustObj$use.findmain <- rep(TRUE, length(M.ppm.findmain))\n  \n  #############\n  ## determine inconsistencies between two scoring methods, select higher MW\n  resolve <- which(abs(ramclustObj$M.ramclustr - ramclustObj$M.findmain)  > (2*mzabs.error))\n  for(i in resolve) {\n    if(ramclustObj$M.ramclustr[i] >  ramclustObj$M.findmain[i]) {\n      ramclustObj$use.findmain[i] <-FALSE\n    }\n  }\n  \n  ramclustObj$M <- ramclustObj$M.findmain\n  ramclustObj$M[!ramclustObj$use.findmain] <- ramclustObj$M.ramclustr[!ramclustObj$use.findmain]\n  ramclustObj$M.ann <- ramclustObj$M.ann.findmain\n  resolved <- which(!ramclustObj$use.findmain)\n  for(i in resolved) {\n    ramclustObj$M.ann[[i]] <- ramclustObj$M.ann.ramclustr[[i]]\n  }\n  \n  #############\n  ## (optionally) plot spectra to pdf\n  if(plot.findmain) {\n    cat(\"plotting findmain annotation results\", '\\n')\n    pdf(\"spectra/findmainPlots.pdf\", width=10, height = 4.6)\n    par(mfrow=c(1,2))\n    for(cl in cmpd) {\n      PlotSpec(x=ramclustObj$M.ann.ramclustr[[cl]], txt=ramclustObj$M.ann.ramclustr[[cl]][,c(\"mz\",\"adduct\")])\n      title(main=list(paste(\n        cl, \":\",\n        \"M.ramclustr =\", \n        round(ramclustObj$M.ramclustr[cl], digits=4), \"( +/-\", round(ramclustObj$M.ppm.ramclustr[cl], digits=1),\n        \"ppm )\"), font = if(ramclustObj$use.findmain[cl]) {1} else {2}, col = if(ramclustObj$use.findmain[cl]) {1} else {2} ))\n      PlotSpec(x=ramclustObj$M.ann.findmain[[cl]], txt=ramclustObj$M.ann.findmain[[cl]][,c(\"mz\",\"adduct\")])\n      title(main = list(paste(\n        cl, \":\",\n        \"M.findmain =\", \n        round(ramclustObj$M.findmain[cl], digits=4), \"( +/-\", round(ramclustObj$M.ppm.findmain[cl], digits=1), \n        \"ppm )\"  ),\n        font = if(ramclustObj$use.findmain[cl]) {2} else {1}, col = if(ramclustObj$use.findmain[cl]) {2} else {1}  ))\n    }\n    dev.off()\n  }\n  \n  #############\n  ## (optionally) write spectra to .mat format in spectra/mat directory\n  if(writeMat) {\n    if(!dir.exists(\"spectra\")) {dir.create(\"spectra\")}\n    list.dirs()\n    dir.create('spectra/mat')\n    for(cl in cmpd) {\n      ms<-ramclustObj$M.ann[[cl]] # ms <- matrix(round(rnorm(30, mean = 700, sd = 200), digits=3), ncol = 3)\n      prcr<-which(ms[,\"adduct\"] %in% ads) # prcr = sample (1:10, 1)\n      prcr<-prcr[which.max(ms[prcr,\"int\"])]\n      prcmz<-ms[prcr,\"mz\"]  # prcmz <- ms[prcr, 1]\n      prctype<-ms[prcr,\"adduct\"] # prctype = \"[M+H]+\"\n      \n      out<-paste(\n        \"NAME: \", ramclustObj$cmpd[cl], '\\n',\n        \"RETENTIONTIME: \", round(ramclustObj$clrt[cl], digits=2), '\\n',\n        \"PRECURSORMZ: \", prcmz, '\\n',\n        \"PRECURSORTYPE: \", prctype, '\\n',\n        \"IONTYPE: \", mode, '\\n', \n        \"SPECTRUMTYPE: Centroid\", '\\n',\n        if((!is.null(ramclustObj$msmsint))) {paste(\"COLLISIONENERGY: \", as.character(ramclustObj$ExpDes[[2]][which(row.names(ramclustObj$ExpDes[[2]]) == \"CE2\"),1]), '\\n', sep=\"\")},\n        \"MSTYPE: \", \"MS1\", '\\n',\n        \"Num Peaks: \", nrow(ms), '\\n', sep=\"\")\n      for(i in 1:nrow(ms)) {\n        out<-paste(out, ms[i,1], \" \", ms[i,2], '\\n', sep=\"\")\n      }\n      \n      \n      if(!is.null(ramclustObj$msmsint)) {\n        do<-which(ramclustObj$featclus == cl)\n        msms<-cbind(\n          'mz' = ramclustObj$fmz[do],\n          'int' = ramclustObj$msmsint[do])\n        msms<-msms[which(msms[,\"mz\"] <= (prcmz + 3)),, drop = FALSE]\n        msms<-msms[order(msms[,\"int\"], decreasing=TRUE),]\n        if(nrow(msms)>0) {\n          out <- paste (out,\n            \"MSTYPE:\" , \"MS2\", '\\n' ,\n            \"Num Peaks: \", nrow(msms), '\\n', \n            sep=\"\")\n          for(i in 1:nrow(msms)) {\n            out<-paste(out, msms[i,1], \" \", msms[i,2], '\\n', sep=\"\")\n          }\n        }\n      }\n      write(out, file=paste0(\"spectra/mat/\", ramclustObj$cmpd[cl], \".mat\"))\n      \n      \n      #   sendToMSF(x = ms, \n      #             precursormz = prcmz, \n      #             precursortype = prctype, \n      #             outfile=paste0(getwd(), \"/spectra/mat/\", ramclustObj$cmpd[cl], \".mat\")# ,\n      #            # MSFexe = \"K:/software/MSFinder/MS-FINDER program ver. 2.20\"\n      #             )\n    }\n  }\n  \n  cat(\"finished\", '\\n')\n  return(ramclustObj)\n  \n}\n\n",
    "created" : 1506351605922.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2580520619",
    "id" : "6A105A07",
    "lastKnownWriteTime" : 1506449942,
    "last_content_update" : 1506457026423,
    "path" : "~/GitHub/RAMClustR/R/do.findmain.R",
    "project_path" : "R/do.findmain.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}