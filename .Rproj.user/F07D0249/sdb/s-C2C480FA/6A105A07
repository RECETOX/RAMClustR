{
    "collab_server" : "",
    "contents" : "#' do.findmain\n#'\n#' cluster annotation function \n#'\n#' This is the Details section\n#'\n#' @param ramclustObj ramclustR object to annotate. \n#' @param cmpd integer: vector defining compound numbers to annotated.  if NULL (default), all compounds\n#' @param mode character: \"positive\" or \"negative\"\n#' @param mzabs.error numeric: absolute mass deviation allowd\n#' @param ppm.error numeric: ppm mass error added to mzabs.error\n#' @param ads character: vector of allowed adducts, i.e. c(\"[M+H]+\")\n#' @param nls  character: vector of allowed neutral losses, i.e. c(\"[M+H-H2O]+\")\n#' @param adwts numeric: vector of weights for adducts. length should match that of 'ads', else first value will be repeated.  if NULL (default), value of 1 is assigned to all. Only used for ramclustR scoring of M.\n#' @param nlwts numeric: vector of weights for neutral losses. length should match that of 'nls', else first value will be repeated.  if NULL (default), value of 0.1 is assigned to all.  Only used for ramclustR scoring of M.\n#' @param plot.findmain logical: should pdf polts be generated for evaluation?\n#' @param writeMat logical: should indidual .mat files (for MSFinder) be generated in a 'mat' subdirectory in the 'spectra' folder?\n\n#' @return a partially annotated ramclustR object.  base structure is that of a standard R heirarchical clustering output, with additional slots described in ramclustR documentation (?ramclustR).  New slots added after using the interpretMSSpectrum functionality include:\n#' @return more slots to describe.  \n#' @author Corey Broeckling\n#' @export\n\n\ndo.findmain<-function(ramclustObj = RC, \n                      cmpd = NULL,\n                      mode = \"positive\", \n                      mzabs.error = 0.01, \n                      ppm.error = 10, \n                      ads = NULL, \n                      nls = NULL, \n                      adwts = NULL, \n                      nlwts=NULL, \n                      plot.findmain=TRUE, \n                      writeMat=TRUE) {\n  require(InterpretMSSpectrum)\n  if(is.null(ads)) {\n    ads<-c(\"[M+H]+\", \"[M+Na]+\", \"[M+K]+\", \"[M+NH4]+\", \"[2M+H]+\", \"[2M+Na]+\", \n           \"[2M+K]+\", \"[2M+NH4]+\", \"[3M+H]+\", \"[3M+Na]+\", \"[3M+K]+\", \"[3M+NH4]+\")\n  }\n  \n  if(is.null(nls)) {\n    nls<-c(\"[M+H-NH3]+\", \"[M+H-H2O]+\", \"[M+H-COCH2]+\", \"[M+H-CO2]+\", \"[M+H-NH3-CO2]+\", \n           \"[M+H-NH3-HCOOH]+\", \"[M+H-NH3-H2O]+\", \"[M+H-NH3-COCH2]+\", \"[M+H-S]+\", \n           \"[M+H-S-NH3-HCOOH]+\", \"[M+H-H4O2]+\", \"[M+H-CH2]+\", \"[M+H-O]+\", \n           \"[M+H-C2H2]+\", \"[M+H-C2H4]+\", \"[M+H-CO]+\", \"[M+H-C3H6]+\", \"[M+H-C2H4O]+\", \n           \"[M+H-C4H6]+\", \"[M+H-C3H4O]+\", \"[M+H-C4H8]+\", \"[M+H-C5H8]+\", \n           \"[M+H-C4H6O]+\", \"[M+H-C5H10]+\", \"[M+H-C6H12]+\", \"[M+H-C4H8O2]+\", \n           \"[M+H-H2O-HCOOH]+\", \"[M+H-CH4]+\", \"[M+H-CH2O]+\", \"[M+H-C2H6]+\", \n           \"[M+H-CH3OH]+\", \"[M+H-C3H4]+\", \"[M+H-C3H6O]+\", \"[M+H-CO2-C3H6]+\", \n           \"[M+H-SO3]+\", \"[M+H-SO3-H2O]+\", \"[M+H-SO3-H2O-NH3]+\", \"[M+H-NH3-C3H4]+\", \n           \"[M+H-H2O-CO2]+\", \"[M+H-H2O-H2O-C2H4O]+\", \"[M+H-NH3-CO-CO]+\", \n           \"[M+H-NH3-CO-COCH2]+\", \"[M+H-C8H6O]+\", \"[M+H-C8H6O-NH3]+\", \"[M+H-C8H6O-H2O]+\", \n           \"[M+H-C2H2O2]+\", \"[M+H-C2H4O2]+\", \"[M+H-C5H8O]+\", \"[M+H-NH3-CO2-CH2O]+\", \n           \"[M+H-NH3-CO2-NH3-H2O]+\", \"[M+H-NH3-CO2-C3H4O]+\", \"[M+H-NH3-CO2-C5H8]+\", \n           \"[M+H-HCOOH-HCOOH]+\", \"[M+H-C2H4-CO2]+\", \"[M+H-C2H4-HCOOH]+\", \n           \"[M+H-NH3-H2O-H2O]+\", \"[M+H-H2O-C2H2O2]+\", \"[M+H-COCH2-C4H8]+\", \n           \"[M+H-NH3-NH3-C3H4]+\", \"[M+H-C2H4O2-CH3OH]+\", \"[M+H-C3H6O-CH3OH]+\", \n           \"[M+H-NH3-CO-COCH2-C4H6O]+\", \"[M+H-C4H6-H2O]+\", \"[M+H-C4H6-C2H4]+\", \n           \"[M+H-C4H6-NH3-H2O]+\", \"[M+H-C4H6-COCH2]+\", \"[M+H-C4H6-C4H6O]+\", \n           \"[M+H-C3H4O-C4H6]+\", \"[M+H-C3H4O-C4H8O2]+\", \"[M+H-C4H8-C4H6]+\", \n           \"[M+H-NH3-HCOOH-CH3OH]+\", \"[M+H-NH3-C2H6]+\", \"[M+H-NH3-C8H6O-CH2]+\", \n           \"[M+H-NH3-C3H4-COCH2]+\", \"[M+H-C3H9N]+\", \"[M+H-C3H9N-C2H4O2]+\", \n           \"[M+H-C6H10O7]+\", \"[M+H-C6H10O7+H2O]+\", \"[M+H-C6H10O7-(H2O)2]+\", \n           \"[M+H-C6H12O6]+\", \"[M+H-C6H12O6+H2O]+\", \"[M+H-C6H12O6-H2O]+\", \n           \"[M+H-C5H10O5]+\", \"[M+H- C5H10O5+H2O]+\", \"[M+H- C5H10O5-H2O]+\", \n           \"[M+H-C2H8NO4P]+\", \"[M+H-(H2O)3-CO]+\", \"[M+H-C6H13NO2]+\", \"[M+H-C5H11NO2]+\", \n           \"[M+H-CH3S]+\", \"[M+H-C8H8O2]+\", \"[M+H-C12H22O11]+\", \"[M+H-C12H24O12]+\", \n           \"[M+H-C12H20O10]+\")\n  }\n  \n  if(length(adwts)>0) {\n    if(length(adwts) != length(ads)) {\n      if(length(adwts) > 1) {\n        warning(\"adduct weight length not equal to adduct length: assigning weight \", adwts[1], \" to all adduct weights\")\n      }\n      adwts<-rep(adwts[1], length(ads)) \n    } \n  } else  {\n    adwts = rep(1, length(ads))\n  }\n  \n  \n  if(length(nlwts)>0) {\n    if(length(nlwts) != length(nls)) {\n      if(length(nlwts) > 1) {\n        warning(\"adduct weight length not equal to adduct length: assigning weight \", nlwts[1], \" to all adduct weights\")\n      }\n      nlwts<-rep(nlwts[1], length(nls)) \n    } \n  } else  {\n    nlwts = rep(0.1, length(nls))\n  }\n  \n  adnlwts<-c(adwts, nlwts); names(adnlwts)<-c(ads, nls)\n  \n  # cat(names(adnlwts),'\\n')\n  # cat(adnlwts,'\\n')\n\n  M.findmain <- rep(NA, max(ramclustObj$featclus))\n  M.ppm.findmain <- rep(NA, max(ramclustObj$featclus))\n  M.ann.findmain <- as.list(rep(NA, max(ramclustObj$featclus)))\n  M.ramclustr <- rep(NA, max(ramclustObj$featclus))\n  M.ppm.ramclustr <- rep(NA, max(ramclustObj$featclus))\n  M.rank.ramclustr <- rep(NA, max(ramclustObj$featclus))\n  M.ann.ramclustr <- as.list(rep(NA, max(ramclustObj$featclus)))\n  \n  \n  if(is.null(cmpd)) {cmpd <- (1:max(ramclustObj$featclus)) }\n  \n  for(cl in cmpd){\n    s<-data.frame(\"mz\"=ramclustObj$fmz[which(ramclustObj$featclus==cl)], \"int\"=ramclustObj$msint[which(ramclustObj$featclus==cl)])\n    \n    out<-findMAIN(\n      s, \n      adductmz = NULL, \n      ionmode = mode,\n      adducthyp = ads, \n      ms2spec = NULL, \n      rules = c(ads, nls),\n      mzabs = mzabs.error,\n      ppm = ppm.error, \n      mainpkthr = 0.1, \n      collapseResults = FALSE)\n    \n    summarytable<-summary(out)\n    \n    M.findmain[cl]<-summarytable[1, \"neutral_mass\"]\n    M.ppm.findmain[cl]<-summarytable[1, \"medppm\"]\n    M.ann.findmain[[cl]]<-out[[1]]\n    \n    ## set all major adduct ppm errors to half ppm.error, or 5\n    for(y in 1:length(out)) {\n      keep<-which(!is.na(out[[y]][,\"adduct\"]))  ## which are annotated peaks\n      out[[y]][keep[which(is.na(out[[y]][keep,\"ppm\"]))],\"ppm\"] <- ppm.error/2\n    }\n    \n    summaryscores<-sapply(\n      1:length(out), \n      FUN=function(x) \n      {\n        keep<-which(!is.na(out[[x]][,\"adduct\"]))  ## which are annotated peaks\n        wt<- adnlwts[out[[x]][keep,\"adduct\"]]\n        int<-(out[[x]][keep, \"int\"])^0.1   ## use square root of intensity to prevent bias toward base peak\n        mzerr<-out[[x]][keep, \"ppm\"] \n        # mzerr[is.na(mzerr)]<-0\n        mzerr<-round(exp(-mzerr^2/(2*(ppm.error^2)) ), digits = 4)  ## this is a sigmoid function to weight high ppm error peaks lower\n        #massorder<-order(out[[x]][keep, \"mz\"])\n        massorder<-sqrt(order(out[[x]][keep, \"mz\"]))\n        massorder<-(massorder)/max((massorder))\n        return(sum((massorder *int * mzerr * wt), na.rm=TRUE) + (0.1*length(keep)))  ## product of the intensity and the scaled mzerror\n        # data.frame(keep, wt, int, mzerr, 'ppm'=out[[x]][keep, \"ppm\"], massorder, 'score'=(massorder *int * mzerr * wt))\n      }\n    )\n    \n    ## the result with the best summaryscore can be selected \n    ## and tagged as such somehow\n    \n    best<-which.max(summaryscores)\n    \n    M.ramclustr[cl]<-summarytable[best, \"neutral_mass\"]\n    M.ppm.ramclustr[cl]<-summarytable[best, \"medppm\"]\n    M.rank.ramclustr[cl]<-best\n    M.ann.ramclustr[[cl]]<-out[[best]]\n    \n    if(10*round(cl/10, digits=0) == cl) {\n      cat(cl, \"of\", max(ramclustObj$featclus), '\\n')\n    }\n  } \n  \n  ramclustObj$M.ramclustr <- M.ramclustr\n  ramclustObj$M.ppm.ramclustr <- M.ppm.ramclustr\n  ramclustObj$M.rank.ramclustr <- M.rank.ramclustr\n  ramclustObj$M.ann.ramclustr <- M.ann.ramclustr\n  ramclustObj$M.findmain <- M.findmain\n  ramclustObj$M.ppm.findmain <- M.ppm.findmain\n  ramclustObj$M.ann.findmain <- M.ann.findmain\n  ramclustObj$use.findmain <- rep(TRUE, length(M.ppm.findmain))\n  \n  resolve <- which(abs(ramclustObj$M.ramclustr - ramclustObj$M.findmain)  > (2*mzabs.error))\n  for(i in resolve) {\n    if(ramclustObj$M.ramclustr[i] >  ramclustObj$M.findmain[i]) {\n      ramclustObj$use.findmain[i] <-FALSE\n    }\n  }\n  \n  ramclustObj$M<-ramclustObj$M.findmain\n  ramclustObj$M[!ramclustObj$use.findmain]<-ramclustObj$M.ramclustr[!ramclustObj$use.findmain]\n  ramclustObj$M.ann <- ramclustObj$M.ann.findmain\n  resolved <- which(!ramclustObj$use.findmain)\n  for(i in resolved) {\n    ramclustObj$M.ann[[i]]<-ramclustObj$M.ann.ramclustr[[i]]\n  }\n    \n  if(plot.findmain) {\n    cat(\"plotting findmain annotation results\", '\\n')\n    pdf(\"spectra/findmainPlots.pdf\", width=10, height = 4.6)\n    par(mfrow=c(1,2))\n    for(cl in cmpd) {\n      PlotSpec(x=ramclustObj$M.ann.ramclustr[[cl]], txt=ramclustObj$M.ann.ramclustr[[cl]][,c(\"mz\",\"adduct\")])\n      title(main=list(paste(\n        cl, \":\",\n        \"M.ramclustr =\", \n        round(ramclustObj$M.ramclustr[cl], digits=4), \"( +/-\", round(ramclustObj$M.ppm.ramclustr[cl], digits=1),\n        \"ppm )\"), font = if(ramclustObj$use.findmain[cl]) {1} else {2}, col = if(ramclustObj$use.findmain[cl]) {1} else {2} ))\n      PlotSpec(x=ramclustObj$M.ann.findmain[[cl]], txt=ramclustObj$M.ann.findmain[[cl]][,c(\"mz\",\"adduct\")])\n      title(main = list(paste(\n        cl, \":\",\n        \"M.findmain =\", \n        round(ramclustObj$M.findmain[cl], digits=4), \"( +/-\", round(ramclustObj$M.ppm.findmain[cl], digits=1), \n        \"ppm )\"  ),\n            font = if(ramclustObj$use.findmain[cl]) {2} else {1}, col = if(ramclustObj$use.findmain[cl]) {2} else {1}  ))\n    }\n    dev.off()\n  }\n  \n  if(writeMat) {\n    dir.create('spectra/mat')\n    for(cl in cmpd) {\n      ms<-ramclustObj$M.ann[[cl]]\n      prcr<-which(ms[,\"adduct\"] %in% ads)\n      prcr<-prcr[which.max(ms[prcr,\"int\"])]\n      prcmz<-ms[prcr,\"mz\"]\n      prctype<-ms[prcr,\"adduct\"]\n      \n      if(!is.null(ramclustObj$msmsint)) {\n        do<-which(ramclustObj$featclus == cl)\n        msms<-cbind(\n          'mz' = ramclustObj$fmz[do],\n          'int' = ramclustObj$msmsint[do])\n        msms<-msms[which(msms[,\"mz\"] <= (prcmz + 3)),]\n        msms<-msms[order(msms[,\"int\"], decreasing=TRUE)]\n      }\n      \n      sendToMSF(x = ms, \n                precursormz = prcmz, \n                precursortype = prctype, \n                outfile=paste0(getwd(), \"/spectra/mat/\", ramclustObj$cmpd[cl], \".mat\")# ,\n               # MSFexe = \"K:/software/MSFinder/MS-FINDER program ver. 2.20\"\n                )\n    }\n  }\n  cat(\"finished\", '\\n')\n  return(ramclustObj)\n  \n}\n\n# rcbackup<-RC\n# RC2<-do.findmain(ramclustObj = RC, cmpd = c(1:15, 625) )\n",
    "created" : 1506351605922.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "226738660",
    "id" : "6A105A07",
    "lastKnownWriteTime" : 1506365519,
    "last_content_update" : 1506365519359,
    "path" : "~/GitHub/RAMClustR/R/do.findmain.R",
    "project_path" : "R/do.findmain.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}